1.Find the duplicate in an array of N+1 integers. 
--------------------------------------------------------------------------------------
using sorting

int findDuplicate(vector<int>& nums) {
	//Since we are sure that if only two elements are there, both will be same
       	 if(nums.size() == 2){
       	     return nums[0];
     	   }        
     	   // sorting so that the duplicate numbers come together
     	   sort(nums.begin() , nums.end());
     	   for(int i = 1 ; i < nums.size() - 1 ; i++){
       	     if(nums[i-1] == nums[i] || nums[i] == nums[i+1]){
       	         return nums[i];
   	         }
     	   }
  	  }
Time Complexity- O(nlogn)
Space Complexity-O(1)
---------------------------------------------------------------------------------------
Using sets

int findDuplicate(vector<int>& nums) {
        set<int> s;
        if(nums.size() == 2){
            return nums[0];
        }   
        // insert the first element as we start checking inside the loop     
    s.insert(nums[0]);
        for(int i = 1 ; i < nums.size() ; i++){
        	//if and element is not found in a set its index is end index
            if(s.find(nums[i]) != s.end()){
                return nums[i]; // since this element is already present we get to know this is the duplicate
            } else {
                s.insert(nums[i]);
            }
        }
        return -1;
    }

Time complexity : O(n)
Space Complexity : O(n)
----------------------------------------------------------------------------------------
Floyds Tortoise and Hare (Cycle Detection)

 int findDuplicate(vector<int>& nums) {
        int hare = nums[0];
        int tortoise = nums[0];
        //Phase 1: 1 round when they have their 1st intersection.
        do {
            tortoise = nums[tortoise];
            hare = nums[nums[hare]];
        } while(hare != tortoise);
            //Phase 2: we will now start the tortoise from begining and they both will meet at the start of the cycle
            tortoise = nums[0];
        while( tortoise != hare){
           tortoise = nums[tortoise];
           hare = nums[hare];
        }
        return hare;
         
    }

Time complexity : O(n)
Space Complexity : O(1)
=======================================================================================
2. Sort array containing 0s, 1s, 2s
-----------------------------------------------------------------------------------------
two pass
void sortColors(vector<int>& nums) {
        int one = 0 ;
        int two = 0 ;
        int zero = 0 ;
        // loop to count occurance of 0s 1s and 2s
        for(int i = 0 ; i < nums.size() ; i++){
            if(nums[i] == 0){
                zero++;
            }
            if(nums[i] == 1){
                one++;
            }
            if(nums[i] == 2){
                two++;
            }
        }
        // loop to fill them according to their occurence
        for(int  i = 0 ; i < nums.size() ; i++){
            if(i<zero){
                nums[i] = 0;
            } else if(i >= zero && i <one + zero){
                nums[i] = 1;
            } else {
                nums[i] = 2;
            }
        }
    }

Time complexity : O(n)
Space Complexity : O(1)
----------------------------------------------------------------------------------------
One Pass Two pointer method

   void sortColors(vector<int>& nums) {
        int low = 0 ;
        int mid = 0 ;
        int high = nums.size() - 1 ;
        while(mid <= high){
          
            if(nums[mid] == 0){
                 int temp;
               temp = nums[mid];
                nums[mid] = nums[low];
                nums[low] = temp;
                mid++; //since the number of zero has increased
                low++; // since we swapped zero to low index
                
            } else if(nums[mid] == 2){
                 int temp;
               temp = nums[mid];
                nums[mid] = nums[high];
                nums[high] = temp;
                high--; //since 2 is from the last so going backward
            } else{
                mid++; // since encountered one
           }
        }
       
  }

Time complexity : O(n)
Space Complexity : O(1)
--------------------------------------------------------------------------------------
One pass Two pointer using swap

void sortColors(vector<int>& nums) {
        int low = 0;
        int mid = 0;
        int high = nums.size() - 1;
        
        while(mid <= high){
            if(nums[mid] == 0){
                std::swap(nums[mid], nums[low]);
                low++;
                mid++;
            }
            else if(nums[mid] == 2){
                std::swap(nums[mid], nums[high]);
                high--;
            }
            else
                mid++;
        }
    }

Time complexity : O(n)
Space Complexity : O(1)
========================================================================================
3. Find Missing And Repeating number from an array containing numbers from 1 to n
------------------------------------------------------------------------------------
Using Hashing

void findmissing(vector<int> &arr){
    int n = arr.size();
   vector<int> hash(n+1,0); // hash array to keep count of number of occurances of numbers in the array
   for(int i = 0 ; i < n ; i++){
       hash[arr[i]] += 1;  
   }
   int missing;
   int twice;
   for( int i = 1 ; i < n+1 ; i++){
       if(hash[i] == 0){
           missing = i;
       } if(hash[i] > 1){
           twice = i;
       }
   }
   cout<<twice<<" "<<missing<<endl;
}

Time complexity : O(n)
Space Complexity : O(n)
---------------------------------------------------------------------------------------
Using XOR
  
#include <bits/stdc++.h> 
using namespace std; 
  
/* The output of this function is stored at 
*x and *y */
void getTwoElements(int arr[], int n, 
                    int* x, int* y) 
{ 
    /* Will hold xor of all elements  
    and numbers from 1 to n */
    int xor1; 
  
    /* Will have only single set bit of xor1 */
    int set_bit_no; 
  
    int i; 
    *x = 0; 
    *y = 0; 
  
    xor1 = arr[0]; 
  
    /* Get the xor of all array elements */
    for (i = 1; i < n; i++) 
        xor1 = xor1 ^ arr[i]; 
  
    /* XOR the previous result with numbers  
    from 1 to n*/
    for (i = 1; i <= n; i++) 
        xor1 = xor1 ^ i; 
  
    /* Get the rightmost set bit in set_bit_no */
    set_bit_no = xor1 & ~(xor1 - 1); 
  
    /* Now divide elements into two  
    sets by comparing a rightmost set 
    bit of xor1 with the bit at the same  
    position in each element. Also,  
    get XORs of two sets. The two 
    XORs are the output elements.  
    The following two for loops  
    serve the purpose */
    for (i = 0; i < n; i++) { 
        if (arr[i] & set_bit_no) 
            /* arr[i] belongs to first set */
            *x = *x ^ arr[i]; 
  
        else
            /* arr[i] belongs to second set*/
            *y = *y ^ arr[i]; 
    } 
    for (i = 1; i <= n; i++) { 
        if (i & set_bit_no) 
            /* i belongs to first set */
            *x = *x ^ i; 
  
        else
            /* i belongs to second set*/
            *y = *y ^ i; 
    } 
  
    /* *x and *y hold the desired 
        output elements */
} 
  
/* Driver code */
int main() 
{ 
    int arr[] = { 1, 3, 4, 5, 5, 6, 2 }; 
    int* x = (int*)malloc(sizeof(int)); 
    int* y = (int*)malloc(sizeof(int)); 
    int n = sizeof(arr) / sizeof(arr[0]); 
  
    getTwoElements(arr, n, x, y); 
    cout << " The missing element is " << *x << " and the repeating"
         << " number is " << *y; 
    getchar(); 
}
 
Time Complexity: O(n)
Space Complexity: O(1)
======================================================================================
4. Merge two sorted Arrays without extra space 
---------------------------------------------------------------------------------------
Using prebuilt functions

void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       copy(nums2.begin(),nums2.end(), nums1.begin()+m);
        sort(nums1.begin(), nums1.end());
    }

Time Complexity: O((n+m)log(m+n))
Space Complexity: O(1)
--------------------------------------------------------------------------------------
My Implementation

 void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
      int mptr = 0; //to keep track of index of first array
      int nptr = 0; // to keep track of index of second array
      int zeroptr = m;
      // loop till the longer arrays end is reached
      while(nptr < n){
          // to bring zero in place of large number such that it can be filled with smaller number from nums2 arr
          if(nums1[mptr] >= nums2[nptr]){
              int tempzero = zeroptr;
              while(zeroptr > mptr ){
                  std::swap(nums1[zeroptr] , nums1[zeroptr-1]);
                  zeroptr--;
              }
              zeroptr = tempzero + 1;
              nums1[mptr] = nums2[nptr];
              nptr++;
              mptr++;
          } else if( nums1[mptr] == 0 ){
              nums1[mptr] = nums2[nptr];
              mptr++;
              nptr++;
          }
          else {
              mptr++;
          }
          
      }
      // since negative numbers are not taken care of by this method we have to sort it
        sort(nums1.begin(), nums1.end());
        
    }
Time Complexity: O(n^2)
Space Complexity: O(1)

=======================================================================================
5. Kadane s Algorithm
---------------------------------------------------------------------------------------
My implementation after watching the hint

void kadane (vector<int> &arr, int n){
    int max_so_far = INT_MIN ; // since it has to be compared with max_ending_here
    int max_ending_here = 0 ; 
    for(int i = 0 ; i < n ; i++){
        max_ending_here += arr[i];
        if(max_so_far < max_ending_here){
            max_so_far = max_ending_here;
        }
        if(max_ending_here < 0){
            max_ending_here = 0; // if sum till now goes below zero, restart
        }
        
    }
    cout<<max_so_far<<endl;
}

Time Complexity: O(n)
Space Complexity: O(1)
=======> the hint
Initialize:
    max_so_far = 0
    max_ending_here = 0

Loop for each element of the array
  (a) max_ending_here = max_ending_here + a[i]
  (b) if(max_so_far < max_ending_here)
            max_so_far = max_ending_here
  (c) if(max_ending_here < 0)
            max_ending_here = 0
return max_so_far
===========

6. Merge Overlaping Intervals
--------------------------------------------------------------------------------------
Inplace operations

#include<bits/stdc++.h>
using namespace std;
// structure to store start and end of interval
struct Interval{
    int start;
    int end;
};

bool compareStart(Interval i1, Interval i2){
    return (i1.start < i2.start);
}

void overlap(Interval interval[] , int n){
    if(n<=0){
        return; // if array is empty
    }
    
    sort(interval, interval + n , compareStart); //sorting according to start of interval quiery
    
    int index = 0;  // since it will be used to compare with the next interval 
      
    for (int i=1; i<n; i++)  
    {  
        
        if (interval[index].end >=  interval[i].start)  // if they overlap
        {  
                 
            interval[index].end = max(interval[index].end, interval[i].end);  //till the end of indexes whichever longer
            interval[index].start = min(interval[index].start, interval[i].start);  // till the start of indexes whichever shorter
        }  
        else { 
            index++; 
            interval[index] = interval[i];  
        }     
    }  
    for (int i = 0; i <= index; i++)  {
        cout  << interval[i].start << " " << interval[i].end << " ";
}
    cout<<endl;
}

int main()
 {
	//code
	int t;
	cin>>t;
	for(int i = 0 ; i < t ; i++){
	    int n;
	    cin>>n;
	    Interval interval[n];
	    for(int i = 0 ; i < n ; i++){
	        Interval inte;
	       for(int j = 0 ; j < 2 ; j++){
	           if(j == 0){
	           cin>>inte.start;
	           } else {
	               cin>>inte.end;
	           }
	       }
	       interval[i] = inte;
	    }
	overlap(interval, n ) ;   
	}
	
	return 0;
}

===================================================================================
7. set matrix zeroes
---------------------------------------------------------------------
1st approach go through each element and set them as some other value so that we can accordingly change other elements.

Time Complexity: O(n^3)
Space Complexity: O(1)

2nd approach is to have a row and a column array which keeps track of the rows and columns which are to be zeroed 

Time Complexity: O(row*col)
Space Complexity: O(row+col)

Best approach

void setZeroes(vector<vector<int>>& matrix) {
    int col0 = 1, row = matrix.size(), col = matrix[0].size(); // col0 to tell if the first column is to be zeroed or not
        
        for(int i = 0 ; i < row ; i++){
            if(matrix[i][0] == 0) col0 = 0; // if any of the first column elements are zero 
            for(int j = 1 ; j < col ; j++){
                if(matrix[i][j] == 0){
                    matrix[i][0] = matrix[0][j] = 0; // setting cues in the first column and row to be zero
                }
            }
        }
        // we start the iteration backward
        for(int i = row -1 ; i >= 0 ; i--){
            for(int j = col-1 ; j >= 1; j--){ // we are not changing the first column as it is used for reference
                if(matrix[i][0] == 0 || matrix[0][j] == 0){
                    matrix[i][j] = 0;
                    
                }
            }
            if(col0 == 0 ){
                matrix[i][0] = 0;
            }
        }
    }

Time Complexity: O(row*col)
Space Complexity: O(1)
========================================================================================
8. Morse Code 
--------------------------------------------------------------------------------------
My implementation - Very inefficient

 int uniqueMorseRepresentations(vector<string>& words) {
        vector<string> morse ={".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        vector<string> alpha={"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"};
        map <string, string> translation;
        for(int i = 0 ; i < 26 ; i++){
            translation.insert(pair<string,string>(alpha[i],morse[i]));
        }
        unordered_set<string> us;
        string str;
        for(int i = 0 ; i < words.size() ; i++){
             str = "";
            for(int j = 0 ; j < words[i].size() ; j++){
                string letter;
                letter += words[i][j];
                map<string,string>::iterator pos = translation.find(letter);
                str= str + pos->second;
            }
            us.insert(str);
        }
        return us.size();
    }
--------------------------------------------------------------------------------------------------------
Efficient one

 int uniqueMorseRepresentations(vector<string>& words) {
            ios_base::sync_with_stdio(false);
            vector<string> morse_code = { ".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."
            };
             unordered_set<string> us;
            string str;
           // vector<string> code_words;
            for(int i = 0; i < words.size(); i++){
                    str = "";
                    for(int j = 0; j < words[i].size(); j++){
                            str += morse_code[words[i][j] - 'a'];
                    }
                    us.insert(str);
            }
            return us.size();
    }

============================================================================================
9. The game of life
--------------------------------------------------------------------------------
Efficient approach using hashmap

void gameOfLife(vector<vector<int>>& board) {
        if(!board.size()) // if the board is empty
            return;
        int i, j, m=board.size(), n=board[0].size();
        unordered_map<int, int> mp={{0, 0}, {1, 1}, {2, 0}, {3, 1}}; // if two people around he dies , if three around he stays alive
        for(i=0; i<m; i++){
            for(j=0; j<n; j++){
                int a = ( i-1>=0 ? mp[board[i-1][j]] : 0) +
                        ( i-1>=0 && j+1<n  ? mp[board[i-1][j+1]] : 0) +
                        ( i-1>=0 && j-1>=0 ? mp[board[i-1][j-1]] : 0) +
                        ( j-1>=0 ? mp[board[i][j-1]] : 0) +
                        ( j+1<n ? mp[board[i][j+1]] : 0) +
                        ( i+1<m ? mp[board[i+1][j]] : 0) +
                        ( i+1<m && j+1<n ? mp[board[i+1][j+1]] : 0) +
                        ( i+1<m && j-1>=0 ? mp[board[i+1][j-1]] : 0);
                if(board[i][j] && (a==2 || a==3))
                    continue; // he stays alive if 2 or 3 are around him
                else if(board[i][j] && a<2)
                    board[i][j]=3; //we are assigning 3 because he is alive now but will die later
                else if(board[i][j] && a>3)
                    board[i][j]=3;
                else if(!board[i][j] && a==3)
                    board[i][j]=2; // because he is dead now but will rebirth later
            }
        }
        mp[2]=1;
        mp[3]=0;
        for(i=0; i<m; i++){
            for(j=0; j<n; j++)
                board[i][j]=mp[board[i][j]];
        }
        return;
    }

Time Complexity: O(m*n)
Space Complexity: O(1)
------------------------------------------------------------------------------------
====================================================================================
10. Pascal s Triangle
------------------------------------------------------------------------------------
After getting some hints

 vector<vector<int>> generate(int numRows) {
        vector<vector<int>> pascal(numRows);
        for(int i = 0 ; i < numRows ; i++){
            pascal[i] = vector<int> (i+1 , 1); // intitialize array with ones
        }
        for(int i = 1 ; i <numRows ; i++){
            for( int j = 1 ; j < pascal[i].size() -1 ; j++ ){
                pascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j];
            }
        }
        return pascal;
    }

Time Complexity: O(n^2)
Space Complexity: O(1)
----------------------------------------------------------------------------------

==================================================================================
11. Next Permutation- Lexicographically next number(dictionary order)
----------------------------------------------------------------------------------
void nextPermutation(vector<int>& nums) {
	// there is no permutation with a single digit
       if(nums.size() <= 1) return;
        int i = nums.size() -2 ;
        // to bring i till the number from where next digits are smaller
        while( i >= 0 && nums[i] >= nums[i+1]) i--;
        if( i >= 0){
            int j = nums.size() - 1;
            while( nums[j] <= nums[i] ) j--; // number just smaller than that on index i
            std::swap(nums[i],nums[j]); 
        }
        reverse(nums, i+1 , nums.size() - 1);
    }
    // function to reverse the numbers
    void reverse(vector<int> &nums, int i, int j ){
        while(i < j) {
            std::swap(nums[i], nums[j]);
            i++;
            j--;
    }
    }

Time Complexity: O(n)
Space Complexity: O(1)
----------------------------------------------------------------------------------
==================================================================================
12. Inversion of array
---------------------------------------------------------------------------------
Brute Force Approach

#include<iostream>
#include<vector>
using namespace std;

int inversion(vector<int> &arr , int n){
        int count = 0 ; 
        for(int i = 0 ; i < n-1 ; i++){
            for(int j = i+1 ; j < n ; j++){
                if(arr[i] > arr[j]){
                    count++;
                }
            }
        }
        return count;
}
int main()
 {
	//code
	int t;
	cin>>t;
	for(int i = 0 ; i < t ; i++ ){
        int n;
        cin>>n;
        vector<int> arr(n);
        for(int i = 0 ; i< n ; i++){
            cin>>arr[i];
        }
        int count = inversion(arr,n);
        cout<<count<<endl;
	}
	return 0;
}
Time Complexity- O(n*n)
Space Complexity- O(1)
------------------------------------------------------------------------------------
Using merge sort

// C++ program to Count 
// Inversions in an array 
// using Merge Sort 
#include <bits/stdc++.h> 
using namespace std; 
  
int _mergeSort(int arr[], int temp[], int left, int right); 
int merge(int arr[], int temp[], int left, int mid, int right); 
  
/* This function sorts the input array and returns the  
number of inversions in the array */
int mergeSort(int arr[], int array_size) 
{ 
    int temp[array_size]; // temp array to store the merged array temporarily
    return _mergeSort(arr, temp, 0, array_size - 1); 
} 
  
/* An auxiliary recursive function that sorts the input array and  
returns the number of inversions in the array. */
int _mergeSort(int arr[], int temp[], int left, int right) 
{ 
    int mid, inv_count = 0; 
    if (right > left) { 
        /* Divide the array into two parts and  
        call _mergeSortAndCountInv()  
        for each of the parts */
        mid = (right + left) / 2; 
  
        /* Inversion count will be sum of  
        inversions in left-part, right-part  
        and number of inversions in merging */
        inv_count += _mergeSort(arr, temp, left, mid); 
        inv_count += _mergeSort(arr, temp, mid + 1, right); 
  
        /*Merge the two parts*/
        inv_count += merge(arr, temp, left, mid + 1, right); 
    } 
    return inv_count; 
} 
  
/* This funt merges two sorted arrays  
and returns inversion count in the arrays.*/
int merge(int arr[], int temp[], int left, 
          int mid, int right) 
{ 
    int i, j, k; 
    int inv_count = 0; 
  
    i = left; /* i is index for left subarray*/
    j = mid; /* j is index for right subarray*/
    k = left; /* k is index for resultant merged subarray*/
    while ((i <= mid - 1) && (j <= right)) { 
        if (arr[i] <= arr[j]) { 
            temp[k++] = arr[i++]; 
        } 
        else { 
            temp[k++] = arr[j++]; 
  
            /* this is tricky -- see above  
            explanation/diagram for merge()*/
            inv_count = inv_count + (mid - i); 
        } 
    } 
  
    /* Copy the remaining elements of left subarray  
(if there are any) to temp*/
    while (i <= mid - 1) 
        temp[k++] = arr[i++]; 
  
    /* Copy the remaining elements of right subarray  
(if there are any) to temp*/
    while (j <= right) 
        temp[k++] = arr[j++]; 
  
    /*Copy back the merged elements to original array*/
    for (i = left; i <= right; i++) 
        arr[i] = temp[i]; 
  
    return inv_count; 
} 
  
// Driver code 
int main() 
{ 
    int arr[] = { 1, 20, 6, 4, 5 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    int ans = mergeSort(arr, n); 
    cout << " Number of inversions are " << ans; 
    return 0; 
} 

Time Complexity - O(nlogn)
space complexity - O(n)
-------------------------------------------------------------------------
my implementation

#include<bits/stdc++.h>
using namespace std;

int _mergesort(vector<int>& , vector<int>&  , int , int );
int merge(vector<int>&, vector<int>&, int , int , int );

int mergesort(vector<int> &arr, int n){
    vector<int> temp(n);
    return _mergesort(arr,temp,0,n-1);
}


int _mergesort(vector<int> &arr, vector<int> &temp , int l, int r){
    int mid, inv_count = 0;
    if(r > l){
     mid = (l + r)/2;
     
     inv_count += _mergesort(arr, temp, l, mid);
     inv_count += _mergesort(arr, temp, mid+1, r);
     
     inv_count += merge(arr, temp, l, mid+1, r); // We send m+1 because we need the starting of 2nd sub array
     
    }
    return inv_count;
}

int merge(vector<int> &arr, vector<int> &temp, int l, int m, int r){
    int inv_count = 0;
    int i,k,j;
    i = l;
    k = l;
    j = m;
    while((i <= m-1) && (j <= r)){
        if(arr[i]<=arr[j]){
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            inv_count = inv_count + m - i;
        }
    }
    while(i <= m-1){
         temp[k++] = arr[i++];
    }
     while(j <= r){
         temp[k++] = arr[i++];
         temp[k++] = arr[j++];
    }
    for(i = l; i<= r ; i++){
        arr[i] = temp[i];
    }
    return inv_count;
}


int main()
 {
     int t;
     cin>> t;
     for(int i = 0; i<t ; i++){
     int n;
     cin>>n;
     vector<int> a(n);
     for(int j = 0 ; j < n ; j++){
         cin>>a[j];
     }
     int inv = mergesort(a, n);
     cout<<inv<<endl;
     }
	//code
	return 0;
}
=========================================================================
13. Stocks buy and sell- only one transaction
--------------------------------------------------------------------------
Brute force Implementation - time limit exceeded

 int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1){
            return 0;
        }
        int small = 0;
        int big = prices.size() - 1;
        int maxprofit = 0;
        for(int i = big ; i >=1 ; i--){
            for(int  j = 0 ; j < i ; j++){
                if(prices[i] - prices[j] >= 0){
                 int current_big = prices[i] -prices[j];
                if(current_big >= maxprofit){
                    maxprofit = current_big;
                } 
                }
            }
        }
        return maxprofit;
}

Time Complexity - O(n*n)
space complexity - O(1)
-----------------------------------------------------------------------
Efficient approach

int maxProfit(vector<int>& prices) {
       int min = INT_MAX;
        int max_profit = 0;
        for(int  i = 0 ; i < prices.size() ; i++){
            if(prices[i] < min){
                min = prices[i];
            }
            int profit;
            profit = prices[i] - min;
            if(profit >= max_profit){
                max_profit = profit;
            }
        }
        return max_profit;
    }

Time Complexity - O(n)
space complexity - O(1)
----------------------------------------------------------------------------
=============================================================================
14. Rotate Image
----------------------------------------------------------------------------
My Implementation - efficient

 void rotate(vector<vector<int>>& matrix) {
        int sizei = matrix.size();
        int sizej = matrix[0].size();
        int temp;
        for(int i=0; i<sizei ; i++){
            for(int j =0 ; j<sizej ; j++){
                if(i<j){ //transpose
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;}
            }
        }
        for(int i=0; i<sizei ; i++){
            for(int j =0 ; j< sizej/2 ; j++){
                temp = matrix[i][j];
                matrix[i][j] = matrix[i][sizej-j-1];
                matrix[i][sizej-j-1] = temp;
            }
        }
        
    }

Time Complexity - O(n^2)
space complexity - O(1)
--------------------------------------------------------------------------------
===============================================================================
15. Search in 2D matrix
-----------------------------------------------------------------------------
My implementation

 bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        
         if( n == 0 ){ // []
            return false;
        }
        
        int m = matrix[0].size();
        if(n == 1 && m == 0){ // [[]]
            return false;
        }
        int i = 0;
        while( i < n){
            if(target > matrix[i][m-1]){
                i++;
            } else if(target <= matrix[i][m-1]) {
                for(int j = 0 ; j < m ; j++ ){
                    if(target == matrix[i][j]){
                        return true;
                    }
                }
                goto e;
            }
        }
        e:
        return false;
    }

Time Complexity - O(n)
space complexity - O(1)
----------------------------------------------------------------------------------
Using Binary search

Solution() {
		ios::sync_with_stdio(false);
		cin.tie(NULL);
		cout.tie(NULL);
	}

	bool searchMatrix(vector<vector<int>>& matrix, int target) {
		if (!matrix.size()) return 0;
		int n  = matrix.size(), m = matrix[0].size();
		int lo = 0, hi = m * n - 1;

		while (lo <= hi) {
			int mid = (lo + hi) / 2;
			int f = mid / m, s = mid % m;
			int val = matrix[f][s];
			if (val == target) return 1;
			if (val < target)lo = mid + 1;
			else hi = mid - 1;
		}

		return 0;
	}
Time Complexity - O(log(m*n))
space complexity - O(1)
-------------------------------------------------------------------------------------
=====================================================================================
16. pow(x,n)
-------------------------------------------------------------------------------------
Brute force approach

 double myPow(double x, int n) {
        double ans = x;
        if(n > 0){
            for(int i = 0 ; i<n-1 ; i++){
                ans = ans*x;
            }
            return ans;
        } else if( n < 0) {
            n = -n;
            for(int i = 0 ; i < n-1 ; i++){
                ans = ans*x;
            }
            return 1/ans;
        } else {
            return 1;
        }
    }

Time Complexity - O(n)
space complexity - O(1)
------------------------------------------------------------------------------------
Using binary search

 double myPow(double x, int n) {
        double ans = 1.00;
        long nn = n;
        if( nn < 0) nn = -1 * nn;
        while(nn > 0){
            if( nn % 2 == 1){
                ans = ans*x;
                nn = nn - 1;
            } else {
                x = x*x;
                nn = nn/2;
            }
        }
        if( n < 0){
            return double(1.0)/double(ans);
        }
        return ans;
    }

Time Complexity - O(logn)
space complexity - O(1)
-------------------------------------------------------------------------------------
=====================================================================================
17. Majority Element (n/2)
-------------------------------------------------------------------------------------
My Implementation using stl sort

int majorityElement(vector<int>& nums) {
        int n = nums.size();
        if(n <=2){
            return nums[0];
        }
        sort(nums.begin() , nums.end());
        return nums[n/2];
        
    }

Time Complexity - O(nlogn)
space complexity - O(1)
========================================================================================

18. Majority Element (n/3)
-------------------------------------------------------------------------------------
My Implementation using stl sort and set

vector<int> majorityElement(vector<int>& nums) {
        sort(nums.begin() , nums.end());
        int n = nums.size();
        if( n == 0){
            return {}; 
        }
        if(n == 1){
            return nums;
        }
        if(n == 2){
            if(nums[0] == nums[1]){ // only one majority
                return {nums[0]};
            }
            return nums; // both majority
        }
        set<int> s;
        int count = 0;
        int element = nums[0];
        int i = 0 ;
        while( i < n){
            if(nums[i] == element){
                count += 1;
                if(count > n/3){
                    s.insert(element);
                    count = 0;
                } 
                i++;
            } else {
                element = nums[i];
                count = 1;
                i++;
            }
        }
        vector<int> ans;
        for ( auto it = s.begin(); it != s.end(); it++ ){
            ans.push_back(*it);
        }
        return ans;
    }

Time Complexity - O(nlogn)
space complexity - O(n)
-------------------------------------------------------------------------------------
=====================================================================================
19. Unique Paths
-------------------------------------------------------------------------------------
Using recursion 

int countPath(int i, int j, int n, int m) { 
         if(i == n-1 && j == m-1){
             return 1;
         }
        if(i > n || j > m){
            return 0;
        }
        else return countPath(i,j+1,n,m) + countPath(i+1, j ,n,m);
    } 
    int uniquePaths(int m, int n) {
     int count = countPath(0,0,n,m);
        return count;
    }

------------------------------------------------------------------------------------
===================================================================================
20. Reverse Pairs

Brute force approach

  int reversePairs(vector<int>& nums) {
        int n = nums.size();
        int count = 0 ;
        for(int i = 0 ; i < n-1 ; i++){
            for(int j = i+1 ; j <n ; j++){
                if(nums[i] > 2*nums[j]){
                    count++;
                }
            }
        }
        return count;
    }

Time Complexity - O(n^2)
space complexity - O(1)
--------------------------------------------------------------------------------------
=====================================================================================
21. Binary search
------------------------------------------------------------------------------------
recursive implementation

#include<bits/stdc++.h>
using namespace std;

int binarysearch(vector<int> arr,int k, int left, int right){
    int mid;
    if(left <= right){
     mid = (left + right ) /2;
     
     if(arr[mid] == k){
        return 1;
    }
    if(k < arr[mid]){
    return binarysearch(arr,k,left,mid -1);
    }
    if(k > arr[mid]){
     return binarysearch(arr,k, mid+1, right);
    }
    
    } else {
        return -1;
    }
}

int main()
 {
	//code
	int t;
	cin>>t;
	for(int i = 0 ; i < t ; i++){
	    int n;
	    cin>>n;
	    int k;
	    cin>>k;
	    vector<int> arr(n);
	    for(int i = 0; i < n ; i++){
	        cin>>arr[i];
	    }
	    int found = binarysearch(arr,k,0,n);
	    cout<<found<<endl;
	}
	return 0;
}


-----------------------------------------------------------------------
========================================================================
22. Reverse Integer
-------------------------------------------------------------------------
Given a 32-bit signed integer, reverse digits of an integer.
Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
----------------------------------------------------------------------------
discussion solution

long long reverse(int x) {
        long long int n, res=0;
          while(x!=0)
          {
              n = x%10;
              res = (res*10) + n;
                x = x/10;
            }
            if(res > INT_MAX || res < INT_MIN)
                return 0;
            else  
                return res;
        
        }

-----------------------------------------------------------------------------
=============================================================================
23. Roman to Integers

My Implementation

 int romanToInt(string s) {
        int I = 1, V = 5 , X = 10, L = 50 , C = 100 , D = 500, M = 1000;
        int integer = 0;
        int i = 0;
        while( i < s.size()){
            if(s[i] == 'M'){
                integer += M;
                i++;
            }
            if(s[i] == 'C'){
                if(s[i+1] == 'M'){
                    integer += M - C;
                    i = i + 2;
                } else if(s[i+1] == 'D'){
                    integer += D - C;
                    i = i + 2;
                } else {
                    integer += C;
                    i++;
                }
            }
            if(s[i] == 'D'){
                integer += D;
                i++;
            }
            if(s[i] == 'X'){
                if(s[i+1] == 'L'){
                    integer += L - X;
                    i = i + 2;
                } else if(s[i+1] == 'C'){
                    integer += C - X;
                    i = i + 2;
                } else {
                    integer += X;
                    i++;
                }
            }
            if(s[i] == 'L'){
                integer += L;
                i++;
            }
            if(s[i] == 'I'){
                if(s[i+1] == 'X'){
                    integer += X - I;
                    i = i + 2;
                } else if(s[i+1] == 'V'){
                    integer += V - I;
                    i = i + 2;
                } else {
                    integer += I;
                    i++;
                }
            }
            if(s[i] == 'V'){
                integer += V;
                i++;
        }
           
    }
         return integer;
    }

-------------------------------------------------------------------------------------
=====================================================================================
24. Two Sum
----------------------------------------------------------------------------------
Brute force solution

vector<int> twoSum(vector<int>& nums, int target) {
       int a = 0;
        int b = 0;
      
      
        for(int i=0; i<nums.size()-1;i++){
            for(int j=i+1;j<nums.size();j++){
                if( nums[i]+nums[j]==target){
                    a=i;
                    b=j;
                }
                
            }
        }
      
         return {a,b};
    }

Time Complexity - O(n^2)
space complexity - O(1)
---------------------------------------------------------------------------------
Efficient approach using hash table

  vector<int> twoSum(vector<int>& nums, int target) {
       vector<int> ans;
        unordered_map<int,int> mpp;
        for(int i = 0 ; i < nums.size() ; i++){
            if(mpp.find(target - nums[i]) != mpp.end()){
                ans.push_back(mpp[target-nums[i]]);
                ans.push_back(i);
                return ans;
            } else {
                mpp[nums[i]] = i;
            }
        }
        return ans;
    }

Time Complexity - O(n)  ,in case there are many collusions O(n^2) 
space complexity - O(n)
-----------------------------------------------------------------------------------
===================================================================================
25. 4Sum
-----------------------------------------------------------------------------------
efficient approach

 vector<vector<int>> fourSum(vector<int>& nums, int target) {
        unordered_map <int, vector<pair<int,int>>> mp;
        int n = nums.size();
        map <int,int> marker;
        // Putting all the elements in marker
        for(int i=0; i<n ; i++){
            marker[nums[i]]++;  //storing the frequency of every element in given array
        }
        
        // Mapping every possible distinct pairs to mp
        for(int i = 0 ; i<n ; i++){
            for(int j = i+1 ; j<n ; j++){
                mp[nums[i] + nums[j]].push_back({nums[i],nums[j]}); //keeping the sum and the element used in making the sum
            }
        }
        
        vector<vector<int>> ans;
        
        for(int i = 0 ; i < n ; i++){
            for(int j = i+1 ; j<n ; j++){
                
                if(mp.find(target - (nums[i]+nums[j])) != mp.end()){
                    //if other target -sum is found, then we will compute the answer
                    for(auto itr = mp[target - (nums[i] + nums[j])].begin() ; itr != mp[target - (nums[i] + nums[j])].end() ; itr++){
                    vector<int> temp;
                        temp.push_back(nums[i]);
                        temp.push_back(nums[j]);
                        temp.push_back(itr->first);
                        temp.push_back(itr->second);
                    ans.push_back(temp);
                        
                    map<int,int> test;

                    for(int p=0 ; p<temp.size() ; p++){
                            test[temp[p]]++;
                        }

                    for(int l = 0 ; l <temp.size() ; l++){
                                if(marker[temp[l]] < test[temp[l]]){
                                    //if  temp contains more number of an element  than the real count in array ,the removing the temp from answer
                                    ans.pop_back();
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        
        
        set<vector<int>> x; // To remove the redundant answers in final answer,first putting the entire ans to a new set .
        for(int i = 0 ; i<ans.size();i++){
            vector <int> v = ans[i];
            sort(v.begin(), v.end());
            x.insert(v);
        }
        
        vector<vector<int>> answer(x.begin(), x.end());
        return answer;
        
    }


-------------------------------------------------------------------------------------------------
==================================================================================================
26. Longest consecutive integers in array
-------------------------------------------------------------------------------------------------
My implementation- doesnt work for large inputs 

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
       long long max = INT_MIN;
       long long min = INT_MAX;
        for(int i = 0; i<nums.size() ; i++){
            if(nums[i] >= max){
                max = nums[i];
            }
            if(nums[i] <= min){
                min = nums[i];
            }
        }
        vector<int> ans;
        long long n = nums.size();
        for(int i = 0 ; i<n ; i++){
            if((nums[i]-min < n) || (max - nums[i] > max-n)){
                ans.push_back(nums[i]);
            }
        }
       long long ansmax = INT_MIN;
        long long ansmin = INT_MAX;
        for(int i = 0; i<ans.size() ; i++){
            if(ans[i] >= ansmax){
                ansmax = nums[i];
            }
            if(ans[i] <= ansmin){
                ansmin = nums[i];
            }
        }
       map<int,int> ansseq;
        for(int i = ansmin; i<= ansmax ; i++){
            ansseq.insert(pair<int,int>(i,0));
        }
        for(int i = 0; i< ans.size() ; i++){
            ansseq[ans[i]] = 1;
        }
        int curr_seq=0;
        int longest_seq=INT_MIN;
        for(auto itr = ansseq.begin() ; itr != ansseq.end() ; itr++){
            if(itr->second == 1){
                curr_seq++;
            } else if(itr->second == 0){
                if(curr_seq >= longest_seq){
                    longest_seq = curr_seq;
                }
                curr_seq = 0;
            }
        }
        if(curr_seq >= longest_seq){
                    longest_seq = curr_seq;
                }
        return longest_seq;
    }
};
-------------------------------------------------------------------------------------------------
from discussion

//3 4 2 1 7 6 8
//1->4 2->3   3->2 , 4->4, 6->3 7->2 8->3 
class Solution {
public:
int longestConsecutive(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int,int>mp;
        int res=0,len,start,end;
        for(int i:nums){
            if(mp[i]!=0)
                continue;
            len = mp[i-1]+mp[i+1]+1;
            start = i-mp[i-1];
            end = i+mp[i+1];
            mp[start]=len,mp[end]=len,mp[i]=len;
            res = max(res,len);
        }
        return res;
    }
};
-----------------------------------------------------------------------------------
class Solution {
public:
    int longestConsecutive(vector<int>& nums) 
    {
        map<int, int> m;
        int prev = INT_MIN;
        for(int i=0; i<nums.size(); i++)
        {
            m[nums[i]]++;
            prev = min(prev, nums[i]);
        }
        
        int res=0, count=1;
        
        for(auto it=m.begin(); it!=m.end(); it++)
        {
            if(it->first == prev+1)
                count++;
            else                
                count = 1;
            
            res = max(res, count);
            prev = it->first;
        }
        return res;
    }
};
----------------------------------------------------------------------------------

==================================================================================
27. Longest sequence with total sum zero
---------------------------------------------------------------------------------
Efficient approach using hashing

int maxLen(int A[], int n)
{
    // Your code here
   int sum=0;
   int max_len = 0;
   unordered_map<int,int> mp;
   for(int i = 0 ; i<n ; i++){
       sum = sum + A[i];
       
       if(A[i] == 0 && max_len == 0){
           max_len = 1;
       }
       
       if (sum == 0) {
            max_len = i + 1;
       }
       
        if (mp.find(sum) != mp.end()) { 
            // If this sum is seen before, then update max_len 
            max_len = max(max_len, i - mp[sum]); 
        } 
        else { 
            // Else insert this sum with index in hash table 
            mp[sum] = i; 
        } 
   }
   return max_len;
}
---------------------------------------------------------------------------------------
=======================================================================================
28. XOR queries of a SubArray
-------------------------------------------------------------------------------------
My naive approach

vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {       
        int n = queries.size();
        vector<int> xorArr;
         int start,end;
        for(int i = 0; i < n ; i++){
                 start = queries[i][0];
                 end = queries[i][1];
            int num = 0;
            for(int j = start ; j<= end ; j++){
                num = num^arr[j];
            }
            xorArr.push_back(num);
        }
        return xorArr;
    }

---------------------------------------------------------------------------------------
Using prefix xor

Explaination-Suppose array "c" divides into two parts , "a" and "b",
c = a ^ b, 
then b == c ^ a = a ^ b ^ a = a ^ a ^ b= b, 
so we can use prefix xor.

 vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        int n=arr.size();
        vector<int> xorarr(n);
        vector<int> res;
        int cxor=0;
        for (int i=0;i<n;++i)
        {
                cxor=cxor^arr[i];
                xorarr[i]=cxor;
        }
        for(int i=0;i<queries.size();++i)
        {
            if (queries[i][0]==0)
                res.push_back(xorarr[queries[i][1]]);
            else
                res.push_back((xorarr[queries[i][0]-1])^(xorarr[queries[i][1]]));
        }
        return res;
    }

---------------------------------------------------------------------------------------
========================================================================================
29. Count the number of subarrays having a given XOR
----------------------------------------------------------------------------------------
Naive Approach
----------------------------------------------------------------------------------------
// A simple C++ Program to count all subarrays having 
// XOR of elements as given value m 
#include <bits/stdc++.h> 
using namespace std; 
  
// Simple function that returns count of subarrays 
// of arr with XOR value equals to m 
long long subarrayXor(int arr[], int n, int m) 
{ 
    long long ans = 0; // Initialize ans 
  
    // Pick starting point i of subarrays 
    for (int i = 0; i < n; i++) { 
        int xorSum = 0; // Store XOR of current subarray 
  
        // Pick ending point j of subarray for each i 
        for (int j = i; j < n; j++) { 
            // calculate xorSum 
            xorSum = xorSum ^ arr[j]; 
  
            // If xorSum is equal to given value, 
            // increase ans by 1. 
            if (xorSum == m) 
                ans++; 
        } 
    } 
    return ans; 
} 
  
// Driver program to test above function 
int main() 
{ 
    int arr[] = { 4, 2, 2, 6, 4 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    int m = 6; 
  
    cout << "Number of subarrays having given XOR is "
         << subarrayXor(arr, n, m); 
    return 0; 
} 

----------------------------------------------------------------------------------------
Efficient approach
----------------------------------------------------------------------------------------
1) Initialize ans as 0.
2) Compute xorArr, the prefix xor-sum array.
3) Create a map mp in which we store count of 
   all prefixes with XOR as a particular value. 
4) Traverse xorArr and for each element in xorArr
   (A) If m^xorArr[i] XOR exists in map, then 
       there is another previous prefix with 
       same XOR, i.e., there is a subarray ending
       at i with XOR equal to m. We add count of
       all such subarrays to result. 
   (B) If xorArr[i] is equal to m, increment ans by 1.
   (C) Increment count of elements having XOR-sum 
       xorArr[i] in map by 1.
5) Return ans.
-------------------------------------------------------------------------------------
// C++ Program to count all subarrays having 
// XOR of elements as given value m with 
// O(n) time complexity. 
#include <bits/stdc++.h> 
using namespace std; 
  
// Returns count of subarrays of arr with XOR 
// value equals to m 
long long subarrayXor(int arr[], int n, int m) 
{ 
    long long ans = 0; // Initialize answer to be returned 
  
    // Create a prefix xor-sum array such that 
    // xorArr[i] has value equal to XOR 
    // of all elements in arr[0 ..... i] 
    int* xorArr = new int[n]; 
  
    // Create map that stores number of prefix array 
    // elements corresponding to a XOR value 
    unordered_map<int, int> mp; 
  
    // Initialize first element of prefix array 
    xorArr[0] = arr[0]; 
  
    // Computing the prefix array. 
    for (int i = 1; i < n; i++) 
        xorArr[i] = xorArr[i - 1] ^ arr[i]; 
  
    // Calculate the answer 
    for (int i = 0; i < n; i++) { 
        // Find XOR of current prefix with m. 
        int tmp = m ^ xorArr[i]; 
  
        // If above XOR exists in map, then there 
        // is another previous prefix with same 
        // XOR, i.e., there is a subarray ending 
        // at i with XOR equal to m. 
        ans = ans + ((long long)mp[tmp]); 
  
        // If this subarray has XOR equal to m itself. 
        if (xorArr[i] == m) 
            ans++; 
  
        // Add the XOR of this subarray to the map 
        mp[xorArr[i]]++; 
    } 
  
    // Return total count of subarrays having XOR of 
    // elements as given value m 
    return ans; 
} 
  
// Driver program to test above function 
int main() 
{ 
    int arr[] = { 4, 2, 2, 6, 4 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    int m = 6; 
  
    cout << "Number of subarrays having given XOR is "
         << subarrayXor(arr, n, m); 
    return 0; 
} 
=========================================================================================
30. Longest substring without repeating charecters
----------------------------------------------------------------------------------------
Efficient approach using sets

int lengthOfLongestSubstring(string s) {
        int n=s.length();
        if(n==0)
            return 0;
        set<char> st;
        int maxsize=0;
        int i=0,j=0;
        while(j<n)
        {
            if(st.count(s[j])==0)
            {
                st.insert(s[j]);
                maxsize=max(maxsize,(int)st.size());
                j++;
            }
            else
            {
                st.erase(s[i]);
                i++;
            }
        }
        return maxsize;
    }

------------------------------------------------------------------------------
=============================================================================
31. Reverse a linked list
------------------------------------------------------------------------------
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode*down, *up , *current ; 
        current = head;
        down = nullptr;
        while(current){
            up = current->next;
            current->next = down;
            down = current;
            current = up;
        }
        head = down;
        return head;
    }
};
----------------------------------------------------------------------------
============================================================================
32. Middle of the linked list
--------------------------------------------------------------------------
My Implementation

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        int count = 0 ;
        ListNode *curr = head;
        while(curr){
            count++;
            curr = curr->next;
        }
        if(count == 1){
            return head;
        }
        if(count == 2){
            return head->next;
        }
        
         int mid = count/2 ;
        
         ListNode *curr1 = head;
        while(mid >0){
            curr1 = curr1->next;
            mid--;
        }
        return curr1;
        
    }
};
----------------------------------------------------------------------------
Using stack

ListNode* middleNode(ListNode* head) {
        vector<ListNode*> A = {head};
        while (A.back()->next != NULL)
            A.push_back(A.back()->next);
        return A[A.size() / 2];
    }
    
---------------------------------------------------------------------------- 
============================================================================
33. Merge two sorted linked lists
----------------------------------------------------------------------------
Discussion Solution

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* temp = new ListNode(0);
        ListNode* curr = temp;
        while(l1 != nullptr && l2 != nullptr) {
            
            if(l1->val < l2->val) {
                curr->next = l1;
                l1 = l1->next;
            } else {
                curr->next = l2;
                l2 = l2->next;
            }
            curr = curr->next;
    }
        if (l1 != nullptr) {
            curr->next = l1;
            l1 = l1->next;
        }
        if(l2 != nullptr) {
            curr->next = l2;
            l2 = l2->next;
        }
        return temp->next;
    }
    
----------------------------------------------------------------------------
===========================================================================
34. Remove nth node from the back of the linked list
--------------------------------------------------------------------------
My two pass implementation

 ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == nullptr){
            return head;
        }
        if(head->next == nullptr && n==1){
            return nullptr;
        }
        ListNode *curr = head;
        int num = 0;
        while(curr){
            curr = curr->next;
            num++;
        }
        if(num == 2){
            if(n == 1){
                head->next = nullptr;
                return head;
            } else {
                return head->next;
            }
        }
        if(num == n){
            head = head->next;
            return head;
        }
        curr = head;
        num = num - n - 1;
        while(num >0){
            curr = curr->next;
            num--;
        }
        if(curr->next->next == nullptr){
            curr->next = nullptr;
        } else {
            curr->next = curr->next->next;
        }
        return head;
    }
    
--------------------------------------------------------------------------------
Refined two pass solution

ListNode* removeNthFromEnd(ListNode* head, int n) {
        
        ListNode* curr = head;
        int total = 0;
        while(curr){
            curr = curr->next;
            total++;
        }
        
        int delete_pos = total-1-n;
        if(delete_pos == -1){
            
            return head->next;
        }
        curr = head;
        int len = 0;
        while(curr){
            if(delete_pos == len){
                curr->next = curr->next->next;
            }
            curr = curr->next;
            len++;
        }
    
        return head;
        
        
        
    }
    
-------------------------------------------------------------------------------------------
===========================================================================================
35. Delete a node from linked list if access is given to only that node(the node will not be
tail node)
-------------------------------------------------------------------------------------------
My Implementation

void deleteNode(ListNode* node) {
        ListNode *temp = node;
        temp->val = temp->next->val;
        temp->next = temp->next->next;
    }
    
-----------------------------------------------------------------------------------------
My implementation 2

void deleteNode(ListNode* node) {
       node->val = node->next->val;
        node->next = node->next->next;
    }

---------------------------------------------------------------------------------------
======================================================================================
36. Add two numbers as linked lists
-------------------------------------------------------------------------------------
From discussion

ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        
        ListNode* dummy = new ListNode(0);
        ListNode* l3 = dummy;
        int carry = 0;
        
        while(l1 != 0 && l2 != 0)
        {
            int output = (l1->val + l2->val + carry) % 10;
            carry = (l1->val + l2->val + carry) / 10;
            ListNode* banana = new ListNode(output);
            l3->next = banana;
            l3 = banana;
            l2 = l2->next;
            l1 = l1->next;
        }
        while(l1 != 0)
        {
            int output = (l1->val + carry) % 10;
            carry = (l1->val + carry) / 10;
            ListNode* banana = new ListNode(output);
            l3->next = banana;
            l3 = banana;
            l1 = l1->next;
        }
        while(l2 != 0)
        {
            int output = (l2->val + carry) % 10;
            carry = (l2->val + carry) / 10;
            ListNode* banana = new ListNode(output);
            l3->next = banana;
            l3 = banana;
            l2 = l2->next;
        }
        if(carry != 0)
        {
            ListNode* banana = new ListNode(carry);
            l3->next = banana;
            l3 = banana;
        }
        
        return dummy->next;
        
    }
    
------------------------------------------------------------------------------
=============================================================================
37. Intersection point of two linked list
---------------------------------------------------------------------------  
My Implementation

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *currA = headA;
        ListNode *currB = headB;
        int countA = 0;
        int countB = 0;
        while(currA){
            countA++;
            currA = currA->next;
        }
        while(currB){
            countB++;
            currB = currB->next;
        }
        int diff;
        if(countA > countB){
            diff = countA - countB;
        } else {
            diff = countB - countA;
            ListNode *temp = headA;
            headA = headB;
            headB = temp;
        }
        currA = headA;
        currB = headB;
        while(diff > 0 ){
            diff--;
            currA = currA->next;
        }
        while(currA){
            if(currA == currB){
                return currA;
                break;
            } else {
                currA = currA->next;
                currB = currB->next;
            }
        }
        return nullptr;
    }

------------------------------------------------------------------------------
==============================================================================
38. Linked list palindrome
------------------------------------------------------------------------------
My implementation- using stacks

bool isPalindrome(ListNode* head) {
        stack<int> s;
        if(head == nullptr){
            return true;
        }
        if(head->next == nullptr){
            return true;
        }
        int count = 0 ;
        ListNode *curr = head;
        while(curr){
            count++;
            curr = curr->next;
        }
        if(count == 2){
            if(head->val == head->next->val){
                return true;
            } else{
                return false;
            }
        }
        int mid = count/2;
        int i = 0;
        curr = head;
        while(i < mid){
           
            s.push(curr->val);
            curr= curr->next;
             i++;
        }
        
        if(count%2 != 0){
            curr = curr->next;
            i++;
        }
        
        while(i < count){
            
            if(curr->val == s.top()){
                s.pop();
            }
            curr= curr->next;
            i++;
        }
        if(s.empty() == true){
            return true;
        } else {
            return false;
        }
        
    }
    
-----------------------------------------------------------------------------
Other Implementation- using vector array

bool isPalindrome(ListNode* head) {
        ListNode * temp = head;
        vector<int> nums;
        while(temp){
            nums.push_back(temp->val);
            temp = temp->next;
        }
        int size = nums.size();
        int beg, end;
        if(size % 2 == 0){
                     end = size/2;
            beg = end - 1;
        } else {
            end = size/2 +1;
            beg = size/2 - 1;
        }
        while(beg >= 0 && end <= size-1){
            if(nums[beg] == nums[end]){
                beg--;
                end++;
            } else {
                return false;
            }
        }
        return true;
    }
    
-------------------------------------------------------------------------------    
=============================================================================
39. Reverse Nodes in k-Group
-----------------------------------------------------------------------------
Discussion solution 

class Solution {
    pair<ListNode *, ListNode *> reverseln(ListNode *head, int k){
        if(!head || !(head->next)){
            return {head, head};
        }
        ListNode *toRet = head;
        ListNode *curr = head;
        ListNode *prev = NULL;
        ListNode *next;
        while(curr && k--){
            next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return {prev, toRet};
    }
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head || !head->next || k == 1){
            return head;
        }
        ListNode *cur = head;
        int n = 0;
        while(cur){
            cur = cur->next;
            n++;
        }
        int g = n / k;
        int r = n % k;
        int count = 0;
        cur = head;
        ListNode *prevend = NULL;
        ListNode *ne = NULL;
        while(count<k*g){
            auto toRev = cur;
            int skipcount = 0;
            while(skipcount<k){
                cur = cur->next;
                skipcount++;
            }
            auto t = reverseln(toRev, k);
            auto newhead = t.first;
            auto oldhead = t.second;
            if(count<k){
                ne = newhead;
            }
            if(prevend){
                prevend->next = newhead;
            }
            prevend = oldhead;
            count += k;
        }
        if(cur){
            prevend->next = cur;  
        }
        return ne;
    }
};
----------------------------------------------------------------------------
============================================================================
40. Detect a cycle in linked list

bool hasCycle(ListNode *head) {
        ListNode* curr= head;
        ListNode* curr2 = head;
       
        while(curr2 != nullptr && curr2->next != nullptr){
            curr = curr->next;
            curr2 = curr2->next->next; 
             if(curr == curr2){
                return true;
            }
        }
        return false;
    }

----------------------------------------------------------------------------
============================================================================
41. Detect and tell the starting of loop in a linked list

ListNode *detectCycle(ListNode *head) {
        ListNode *curr = head;
        ListNode *curr2 = head;
    
        while(curr2 != nullptr && curr2->next != nullptr){
            
            curr = curr->next;
            curr2 = curr2->next->next;
            if(curr == curr2){
            curr = head;
                while(curr != curr2){
                    curr = curr->next;
                    curr2 = curr2->next;
                }
                return curr;
            }
        }
        
        return NULL;
    }  
==============================================================================
42. Flatten a linked list
------------------------------------------------------------------------------
Node* merge( Node* , Node* );

Node *flatten(Node *root)
{
   // Your code here
   if(root == nullptr || root->next == nullptr ){
       return root;
   }
   return merge(root , flatten(root->next));
}

Node* merge( Node* a, Node* b){
    if(a== nullptr){
        return b;
    }
    if(b == nullptr){
        return a;
    }
    
    Node* result;
    
    if( a->data < b->data){
        result = a;
        result->bottom = merge(a->bottom, b);
    } else {
        result = b ;
        result->bottom = merge(a, b->bottom); 
    }
    result->next = nullptr;
    return result;
}

==========================================================================
43. Reverse linked list from m to n index // not clear
--------------------------------------------------------------------------
ListNode* reverse(ListNode* head, ListNode* target) { // secondary function
       if(head == nullptr){
           return nullptr; // if we reach the last of linked list
       }
        if(head->next == target){
            return head; 
        }
        ListNode* ret = reverse(head->next, target);
        head->next->next = head;
        head->next = target;
        return ret;
    } 
    
    ListNode* reverseBetween(ListNode* head, int m, int n) { //primary function
       ListNode* prev = new ListNode(0);
        prev->next = head;
        ListNode *prev_ret = prev; // we are going to return its next link
        ListNode *target = head;
        //prefix -- first decreses the value and then uses it
        while(--m){
            prev = prev->next; // so this will land just before the mth index
        }
        //postfix -- first uses its value and then decreses it
        while(n--){
            target = target->next; // this will land at the nth index
        }
        prev->next = reverse(prev->next, target); // this will point to the last of list sent to the function
        return prev_ret->next;
    }

---------------------------------------------------------------------------
===========================================================================
44. Rotate Linked List
--------------------------------------------------------------------------
My implementation

ListNode* rotateRight(ListNode* head, int k) {
        // for empty linked list
        if(!head) return nullptr;
        // for list with only one element
        if(head->next == nullptr) return head;
        
        ListNode *temp = new ListNode(0); // to point at the start of linked list
        temp->next = head;
        ListNode *head1= head;
        ListNode *curr = head;
        int break_ind;
        int count = 0; //we want to know the number of elements
        while(curr){
            curr = curr->next;
            count++;
        }
        k = k%count;
        // if no rotations required
        if(k==0){
            return head;
        } 
        break_ind = count - k -1; // breaks from the index the rotation demands
        curr = head;
        while(break_ind > 0){
            curr = curr->next;
            break_ind--;
        }
        ListNode* last = curr;
        //last->next = nullptr;
        head1 = curr->next;
        while(curr->next){
            curr = curr->next;
        }
        curr->next = temp->next;
        last->next = nullptr;
        return head1;
    }
=========================================================================
45. Join two sorted linked lists

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode dummy = ListNode(0); // to have a starting which will point to one of the linked lists
        ListNode* ans = &dummy;
        
        while(l1 && l2){
            if(l1 -> val < l2 -> val){
                ans -> next = l1; // since it is smaller
                l1 = l1 -> next; // now the pointer points to the next node to compare
            }
            else{
                ans -> next = l2; //same
                l2 = l2 -> next; //same
            }
            ans = ans -> next; // the new link moves as it changes
        }
        
        ans -> next = l1 ? l1 : l2; // we have exhaused one of the loops, so we traverse the other loop completely
        
        return dummy.next; // return answer
    }                    

=========================================================================
46. Insert Interval- 
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.

vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> result;
        
        for (size_t i = 0; i < intervals.size(); i++)
        {
			//  the new interval is after the range of other interval, so we can leave the 
            if (intervals[i][1] < newInterval[0]) //current interval baecause the new one does not overlap with it
            {
                result.push_back(intervals[i]);
            }
			// the new interval's range is before the other, 
            else if (intervals[i][0] > newInterval[1]) // so we can add the new interval and update it to the current one
            {
                result.push_back(newInterval);
                newInterval = intervals[i]; 
            }
			
            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) 
            {
                newInterval[0] = min(intervals[i][0], newInterval[0]); // the new interval is in the range of the other interval, we have an overlap,  
                newInterval[1] = max(newInterval[1], intervals[i][1]); //so we must choose the min for start and max for end of interval

            }
        }
        
        result.push_back(newInterval); 
        return result;
    }
--------------------------------------------------------------------------------------------
============================================================================================
47. Search insert position

int searchInsert(vector<int>& nums, int target) {
        int pos = 0;
        int i = 0 ; 
        if(nums.size() == 0){
            return 0; //since array is empty so put in any direction
        }
        if(nums.size() == 1){
            if(target <= nums[0]){
                return 0; //smaller
            } else {
                return 1; // greater
            }
        }
        while(i < nums.size() - 1){
            if(target == nums[i]){
                return i; // if found
            }
            if(i == 0 && target < nums[i]){
                return 0; // if number exist before the array
            }
            if(target > nums[i] && target < nums[i+1]){
                return i+1; //if the number is in between somewhere
            }
            if(i+1 == nums.size() -1 && target > nums[i+1]){
                return nums.size(); //if number exists after the array
            }
            i++;
        }
        return i; 
    }

--------------------------------------------------------------------------------------------
============================================================================================
48. Maximum consecutive ones

int findMaxConsecutiveOnes(vector<int>& nums) {
        int max_until_now = 0;
        int max = INT_MIN;
        
        for(int i = 0 ; i < nums.size() ; i++){
            if(nums[i] == 1){
                max_until_now++; //if one us found
            } 
            if(max_until_now > max){
                max = max_until_now; // to keep track of the longest streak
            }
            if(nums[i] == 0){
                max_until_now = 0; // if the streak breaks
            }
        }
        return max;
    }
-------------------------------------------------------------------------------
================================================================================
49. Remove duplicates from sorted array

int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0){
            return 0;
        }
        int currentPos=1;
        int arrPos=1 ;
        for(int i=1 ; i< nums.size() ; i++) {
            if(nums[i]==nums[i-1]){
                currentPos += 1; //this moves to find the next distinct number
            }
            else { //when the next distinct number is found this puts that in next array pos
                nums[arrPos] = nums[i];
                arrPos += 1;
                currentPos += 1;
            }
        }
        return arrPos;
    }
----------------------------------------------------------------------------------
============================================================================
50. 3sum
---------------------------------------------------------------------------
2 pointer method

 vector<vector<int>> threeSum(vector<int>& a) {
                vector<vector<int>> v;
            if(a.size()<3) return v;
            int n=a.size();
            sort(a.begin(),a.end()); //sort the vector 

            for(int i=0;i<n-2;i++)
            {
                int l=i+1,r=n-1;
                if(i>0 and a[i]==a[i-1]) // to avoid similiar consequtive numbers
                    continue;
                while(l<r)
                {
                    if(a[i]+a[l]+a[r]==0){
                        v.push_back({a[i],a[l],a[r]});
                    l++; r--;
                    while(a[l]==a[l-1] and l<r) //skip if duplicates are avilable
                        l++;
                    while(l<r and a[r]==a[r+1]) // same as above
                        r--;
                    }
                    else if(a[i]+a[l]+a[r]<0) //if sum is less than desired value  then i will advance one step up from below
                        l++;
                    else // viceversa
                        r--;
                }
            }
            return v;
        }
--------------------------------------------------------------------------------------------   
===========================================================================================
51. Trapping rainwater

int trap(vector<int>& height) {
        int n=height.size();
        if(n==0){
            return 0;
        }
        int left[n]; // this array stimulates the holding of water from left side
        int right[n]; // this array stimulates the holding of water from right side
        left[0]=height[0];
        for(int i=1;i<n;i++){
            left[i]=max(left[i-1],height[i]);
        }
        right[n-1]=height[n-1];
        for(int i=n-2;i>=0;i--){
            right[i]=max(right[i+1],height[i]);
        }      
        int sum=0;
        for(int i=0;i<n;i++){ // here the water level will be the minm of both the left 
            sum+=min(right[i],left[i]) - height[i];  // and right levels - the height already present
        }
        return sum;       
       }
--------------------------------------------------------------------------------------------
========================================================================================
52. Maximum meetings in a room

#include<bits/stdc++.h>
using namespace std;
// Structure for storing starting time,  
// finishing time and position of meeting. 
struct meeting { 
    int start; 
    int end; 
    int pos; 
}; 
// Comparator function which can compare 
// the second element of structure used to 
// sort pairs in increasing order of second value.
bool comparator(struct meeting m1, meeting m2) 
{ 
    return (m1.end < m2.end); 
} 

void meeting(vector<int> &s, vector<int> &f, int n){
    struct meeting meet[n]; 
    for (int i = 0; i < n; i++)  
    { 
        // Starting time of meeting i. 
        meet[i].start = s[i];  
          
        // Finishing time of meeting i 
        meet[i].end = f[i];  
          
        // Original position/index of meeting 
        meet[i].pos = i + 1;  
    } 
  
    // Sorting of meeting according to their finish time. 
    sort(meet, meet + n, comparator); 
  
    // Vector for storing selected meeting. 
    vector<int> m; 
  
    // Initially select first meeting. 
    m.push_back(meet[0].pos); 
  
    // time_limit to check whether new  
    // meeting can be conducted or not. 
    int time_limit = meet[0].end; 
  
    // Check for all meeting whether it  
    // can be selected or not. 
    for (int i = 1; i < n; i++) { 
        if (meet[i].start >= time_limit) 
        { 
            // Push selected meeting to vector 
            m.push_back(meet[i].pos); 
              
            // Update time limit. 
            time_limit = meet[i].end;  
        } 
    } 
  
    // Print final selected meetings. 
    for (int i = 0; i < m.size(); i++) { 
        cout << m[i] << " "; 
    } 
}

int main()
 {
     int t;
     cin>>t;
     for(int i = 0 ; i < t ; i++){
     int n;
     cin>>n;
     vector<int> s(n);
     for(int j = 0 ; j < n ; j++){
         cin>>s[j];
     }
     vector<int> f(n);
     for(int j = 0 ; j < n ; j++){
         cin>>f[j];
     }
     meeting(s, f, n);
     cout<<endl;
     }
	//code
	return 0;
}
======================================================================================
53. Activity selection

#include<bits/stdc++.h>
using namespace std;
struct Act {
int st;
int en;
};

bool comparator(Act start, Act end){
   return (start.en < end.en); 
}

void activitySelection(vector<int> &start, vector<int> &end, int n){
    Act act[n];
    int count=0;
    for(int i = 0 ; i <n  ; i++){
        act[i].st = start[i];
        act[i].en = end[i];
    }
    sort(act,act + n, comparator);
    count++;
    int time_limit = act[0].en;
    for(int i=1; i<n ; i++){
        if(act[i].st >= time_limit){
            count++;
            time_limit = act[i].en;
    }
     
}
cout<<count;
}


int main()
 {
	//code
	int t;
	cin>>t;
	for(int i = 0 ; i < t ; i++){
	    int n;
	    cin>>n;
	    vector<int> start(n), end(n);
	    for(int i = 0 ; i < n ; i++){
	        cin>>start[i];
	    }
	    for(int i = 0 ; i < n ; i++){
	        cin>>end[i];
	    }
	    activitySelection(start, end, n);
	    cout<<endl;
	}
	return 0;
}
==================================================================================
54. Coin piles
---------------------------------------------------------------------------
my implementation

#include<bits/stdc++.h>
using namespace std;

void removeCoins(vector<int> &arr, int n,int k ){
    sort(arr.begin(), arr.end(), greater<int>());
    
    int count = 0;
   
    int min = arr[n-1];
    for(int i = 0; i < n ; i++){
        int diff = arr[i] - min;
        if(diff > k){
            count += (diff- k);
        }
    }
    cout<<count;
}

int main()
 {
	//code
	int t;
	cin>>t;
	for(int i=0 ; i < t ; i++){
	    int n;
	    cin>>n;
	    int k;
	    cin>>k;
	    vector<int> arr(n);
	    for(int i = 0 ; i< n ; i++){
	        cin>>arr[i];
	    }
	    removeCoins(arr,n,k);
	    cout<<endl;
	}
	return 0;
}

--------------------------------------------------------------------------
gfg 

// C++ implementation of the approach 
#include <bits/stdc++.h> 
using namespace std; 

// Function to return the minimum number 
// of coins that need to be removed 
int minimumCoins(int a[], int n, int k) 
{ 
	// To store the coins needed to be removed 
	int cnt = 0; 

	// Minimum value from the array 
	int minVal = *min_element(a, a + n); 

	// Itereate over the array and remove extra coins 
	for (int i = 0; i < n; i++) { 
		int diff = a[i] - minVal; 

		// If the difference between the current pile and 
		// the minimum coin pile is greater than k 
		if (diff > k) { 

			// Count the extra coins to be removed 
			cnt += (diff - k); 
		} 
	} 

	// Return the required count 
	return cnt; 
} 

// Driver code 
int main() 
{ 
	int a[] = { 1, 5, 1, 2, 5, 1 }; 
	int n = sizeof(a) / sizeof(a[0]); 
	int k = 3; 

	cout << minimumCoins(a, n, k); 

	return 0; 
} 

==========================================================================
55. fractional Knapsack

// C/C++ program to solve fractional Knapsack Problem 
#include <bits/stdc++.h> 

using namespace std; 

// Structure for an item which stores weight and corresponding 
// value of Item 
struct Item 
{ 
	int value, weight; 

	// Constructor 
	Item(int value, int weight) : value(value), weight(weight) 
	{} 
}; 

// Comparison function to sort Item according to val/weight ratio 
bool cmp(struct Item a, struct Item b) 
{ 
	double r1 = (double)a.value / a.weight; 
	double r2 = (double)b.value / b.weight; 
	return r1 > r2; 
} 

// Main greedy function to solve problem 
double fractionalKnapsack(int W, struct Item arr[], int n) 
{ 
	// sorting Item on basis of ratio 
	sort(arr, arr + n, cmp); 

	// Uncomment to see new order of Items with their ratio 
	/* 
	for (int i = 0; i < n; i++) 
	{ 
		cout << arr[i].value << " " << arr[i].weight << " : " 
			<< ((double)arr[i].value / arr[i].weight) << endl; 
	} 
	*/

	int curWeight = 0; // Current weight in knapsack 
	double finalvalue = 0.0; // Result (value in Knapsack) 

	// Looping through all Items 
	for (int i = 0; i < n; i++) 
	{ 
		// If adding Item won't overflow, add it completely 
		if (curWeight + arr[i].weight <= W) 
		{ 
			curWeight += arr[i].weight; 
			finalvalue += arr[i].value; 
		} 

		// If we can't add current Item, add fractional part of it 
		else
		{ 
			int remain = W - curWeight; 
			finalvalue += arr[i].value * ((double) remain / arr[i].weight); 
			break; 
		} 
	} 

	// Returning final value 
	return finalvalue; 
} 

// driver program to test above function 
int main() 
{ 
	int W = 50; // Weight of knapsack 
	Item arr[] = {{60, 10}, {100, 20}, {120, 30}}; 

	int n = sizeof(arr) / sizeof(arr[0]); 

	cout << "Maximum value we can obtain = "
		<< fractionalKnapsack(W, arr, n); 
	return 0; 
} 
-------------------------------------------------------------------------
=========================================================================
56. Minimum number of railway platform
------------------------------------------------------------------------
Naive approach

// Program to find minimum number of platforms 
// required on a railway station 
#include <algorithm> 
#include <iostream> 

using namespace std; 

// Returns minimum number of platforms reqquired 
int findPlatform(int arr[], int dep[], int n) 
{ 

	// plat_needed indicates number of platforms 
	// needed at a time 
	int plat_needed = 1, result = 1; 
	int i = 1, j = 0; 

	// run a nested loop to find overlap 
	for (int i = 0; i < n; i++) { 
		// minimum platform 
		plat_needed = 1; 

		for (int j = i + 1; j < n; j++) { 
			// check for overlap 
			if ((arr[i] >= arr[j] && arr[i] <= dep[j]) || 
		(arr[j] >= arr[i] && arr[j] <= dep[i])) 
				plat_needed++; 
		} 

		// update result 
		result = max(result, plat_needed); 
	} 

	return result; 
} 

// Driver program to test methods of graph class 
int main() 
{ 
	int arr[] = { 900, 940, 950, 1100, 1500, 1800 }; 
	int dep[] = { 910, 1200, 1120, 1130, 1900, 2000 }; 
	int n = sizeof(arr) / sizeof(arr[0]); 
	cout << "Minimum Number of Platforms Required = "
		<< findPlatform(arr, dep, n); 
	return 0; 
} 
---------------------------------------------------------------
Greedy approach

// Program to find minimum number of platforms 
// required on a railway station 
#include <algorithm> 
#include <iostream> 

using namespace std; 

// Returns minimum number of platforms reqquired 
int findPlatform(int arr[], int dep[], int n) 
{ 
	// Sort arrival and departure arrays 
	sort(arr, arr + n); 
	sort(dep, dep + n); 

	// plat_needed indicates number of platforms 
	// needed at a time 
	int plat_needed = 1, result = 1; 
	int i = 1, j = 0; 

	// Similar to merge in merge sort to process 
	// all events in sorted order 
	while (i < n && j < n) { 
		// If next event in sorted order is arrival, 
		// increment count of platforms needed 
		if (arr[i] <= dep[j]) { 
			plat_needed++; 
			i++; 
		} 

		// Else decrement count of platforms needed 
		else if (arr[i] > dep[j]) { 
			plat_needed--; 
			j++; 
		} 

		// Update result if needed 
		if (plat_needed > result) 
			result = plat_needed; 
	} 

	return result; 
} 


// Driver program to test methods of graph class 
int main() 
{ 
	int arr[] = { 900, 940, 950, 1100, 1500, 1800 }; 
	int dep[] = { 910, 1200, 1120, 1130, 1900, 2000 }; 
	int n = sizeof(arr) / sizeof(arr[0]); 
	cout << "Minimum Number of Platforms Required = "
		<< findPlatform(arr, dep, n); 
	return 0; 
} 

=================================================================================
57. Job Sequencing

#include<bits/stdc++.h>
using namespace std;
class jobs
{
    public:
    int id;
    int d;
    int p;
};
bool comp(jobs a, jobs b)
{
    if(a.p!=b.p)
    {
        return a.p>b.p;
    }
    return a.id<b.id;
}
int main()
 {
	//code
	int t;
	cin>>t;
	while(t--)
	{
	    int n;
	    cin>>n;
	    jobs *arr=new jobs[n];
	    bool *slots = new bool[n];
	    for(int i=0;i<n;i++)
	    {
	        slots[i]=false;
	    }
	    for(int i=0;i<n;i++)
	    {
	        int id,d,p;
	        cin>>id>>d>>p;
	        arr[i].id=id;
	        arr[i].d=d;
	        arr[i].p=p;
	    }
	    sort(arr,arr+n,comp);
	    int profit=0;
	    int count=0;
	    for(int i=0;i<n;i++)
	    {
	        for(int j=min(n-1,arr[i].d-1);j>=0;j--)
	        {
	            if(!slots[j])
	            {
	                slots[j]=true;
	                count++;
	                profit+=arr[i].p;
	                break;
	            }
	        }
	    }
	     cout<<count<<" "<<profit<<endl;
	}
	return 0;
}

======================================================================================
58. sorting a sub string

#include<bits/stdc++.h>
using namespace std;

string rearrange(string s, int n, int m){
	sort(s.begin()+n,s.begin()+m +1, greater<char>());
	return s;
}

int main(){
	int t;
	cin>>t;
	while(t--){
		string s;
		cin>>s;
		int n,m;
		cin>>n>>m;
		string answer = rearrange(s,n,m);
		cout<<answer<<endl;
	}
	return 0;
}

========================================================================================
59. reverse strings
-----------------------------------------------------------------------------------------
string reverseWords(string s) {
        if(s.empty()){
            return s;
        }
      int j=0;
        while(s[j] == ' '){
            j++;
        }
        if(j == s.length()){
            return "";
        }
        vector<string> vs;
        for(int i = j ; i < s.length() ; i++){
            if(s[i] == ' ' && s[i-1] != ' '){
                vs.push_back(s.substr(j,i-j));
                j = i+1;
            } else if(s[i] == ' ') {
                j++;
            }
        }
        
        if(s[s.length() - 1 ] != ' '){
            vs.push_back(s.substr(j, s.length() - j));
        }
        
        reverse(vs.begin() , vs.end());
        
        string ans;
        
        for(int i = 0 ; i < vs.size() - 1 ; i++){
            ans += vs[i];
            ans += " ";
        }
        ans += vs[vs.size() - 1];
        return ans;
    }
===================================================================================
60. Longest Palindrome

int longestPalindrome(string s) {
        unordered_map<char,int> mp;
        int count = 0 ;
        for(int i = 0 ; i < s.length() ; i++){
            mp[s[i]]++;
        }
        int flag = 0;
        for(auto itr = mp.begin() ; itr != mp.end() ; itr++){
            if((itr->second)%2 == 0){
                count += (itr->second);
            } else {
                flag = 1;
                count += (itr->second - 1);
            }
        }
        if(flag == 1){
            count = count + 1;
        }
        return count;
    }
=================================================================================
61. Integer to Roman

string intToRoman(int num) {
       int index = 0;
       string ans = "";
       int val[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
       string rom[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        while(num>0){
            while(num>=val[index]){
                ans +=rom[index];
                num -=val[index];
            }
            index++;
        }
        return ans;
    }
===============================================================================
62. atoi implementation

bool isNumericChar(char x) 
{ 
    return (x >= '0' && x <= '9') 
               ? true
               : false; 
} 

int atoi(string str)
{
    //Your code here
  int sign = 1, base = 0 , i = 0;
  while(str[i] == ' '){
      i++;
  }
  if(str[i] == '-' || str[i] == '+'){
    sign = 1 - 2*(str[i++] == '-' );    
  }
  while( str[i]){
      if(isNumericChar(str[i]) == false){
          return -1;
      }
      if(base > INT_MAX/10 || (base == INT_MAX/10 && str[i] - '0' > 7)){
          if(sign == 1){
              return INT_MAX;
          } else {
              return INT_MIN;
          }
      }
      base = base*10 + (str[i++] - '0');
  }
  if(sign == -1){
      base = base*(-1);
  }
  return base;
}

======================================================================================
63. Implement strStr() // to see if the needle is a substring of haystack

int strStr(string haystack, string needle) {
        int srcLen = haystack.size();
        int destLen = needle.size();
        
        int ret = -1;
        for(int pos = 0;pos <= srcLen - destLen;pos++)
        {
            int compareIdx = 0;
            for(compareIdx = 0;compareIdx < needle.size();compareIdx++)
            {
                if(haystack[pos + compareIdx] != needle[compareIdx])
                {
                    break;
                }
            }
            if(compareIdx == needle.size())
            {
                ret = pos;
                break;
            }
        }
        return ret;
    }

=====================================================================================
64. Longest common prefix

string longestCommonPrefix(vector<string>& strs) {
        if(strs.size() == 0){
            return "";
        }
        string prefix = "";
        for(int i = 0 ; i < strs[0].size() ; i++){
            for(int j = 0 ; j < strs.size() - 1 ; j++){
                if(strs[j].substr(i,1) != strs[j+1].substr(i,1)){
                    return prefix;
                }
            }
            prefix += strs[0].at(i);
        }
        return prefix;
    }

=====================================================================================
65. Caeser Cipher

string caesarCipher(string s, int k) {
if(s.size() <=0){ //return if empty string
    return "";
}
k = k%26; // to see tha k remains within 26
for(int i = 0 ; i < s.size() ; i++){
    if((s[i] >= 'a') && (s[i] <= 'z')){
        if((s[i] + k > 'z')){
            s[i] = s[i] + k - 26 ; // cyclic increment
        } else {
            s[i] = s[i] + k; //normal increment
        }
    }
    if((s[i] >= 'A') && (s[i] <= 'Z')){
        if((s[i] + k > 'Z')){
            s[i] = s[i] + k - 26 ; 
        } else {
            s[i] = s[i] + k;
        }

    } else {
        continue;
    }
}
return s;
}

=====================================================================================
66. rat in a maze

void getPath(int m[][MAX], int row, int col, bool visited[][MAX], int n, vector<string> &pathSeq, string &path );

bool isSafe(int m[][MAX],int n,int row,int col, bool visited[][MAX]){
    if( row<0 || row>=n || col<0 || col >=n || visited[row][col] || m[row][col] == 0){
        return false;
    }
    return true;
}

void getPath(int m[][MAX], int row, int col, bool visited[][MAX], int n, vector<string> &pathSeq, string &path ){
    if( row<0 || row>=n || col<0 || col >=n || visited[row][col] || m[row][col] == 0){
        return;
    }
    if(row == n-1 && col == n-1){
        pathSeq.push_back(path);
        return;
    }
    visited[row][col] = true;
    //right
    if(isSafe(m,n,row,col+1,visited)){
        path.push_back('R');
        getPath(m,row,col+1,visited,n,pathSeq,path);
        path.pop_back();
    }
    //left
    if(isSafe(m,n,row,col-1,visited)){
        path.push_back('L');
        getPath(m,row,col-1,visited,n,pathSeq,path);
        path.pop_back();
    }
    //down
    if(isSafe(m,n,row+1,col,visited)){
        path.push_back('D');
        getPath(m,row+1,col,visited,n,pathSeq,path);
        path.pop_back();
    }
    //up
    if(isSafe(m,n,row-1,col,visited)){
        path.push_back('U');
        getPath(m,row-1,col,visited,n,pathSeq,path);
        path.pop_back();
    }
    
    visited[row][col] = false;
    
}

vector<string> printPath(int m[MAX][MAX], int n) {
    // Your code goes here
    vector<string> pathSeq;
    string path;
    bool visited[n][MAX];
    memset(visited,false,sizeof(visited));
    getPath(m, 0, 0, visited, n, pathSeq, path);
    sort(pathSeq.begin(), pathSeq.end());
    return pathSeq;
        
    
}

============================================================================
67. N queens

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pb push_back

bool isSafe(int i, int j, int n, int *col){
    for(int k=0; k<i; k++){
        if(col[k] == j){
            return false;
        }
        if(abs(j-col[k]) == abs(i-k)){
            return false;
        }
    }
    return true;
}

void dfs(int i, int *col, int n, int *cnt){
    if(i == n){
        cout<<"[";
        for(int i=0; i<n; i++){
            cout<<col[i]+1<<" ";
        }
        cout<<"] ";
        *cnt = *cnt + 1;
    }
    else{
        for(int j=0; j<n; j++){
            if(isSafe(i, j, n, col)){
                col[i] = j;
                dfs(i+1, col, n, cnt);
            }
        }
    }
}

int main() {
	ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    ll t;
    cin>>t;
    while(t--)
    {
        int n;   cin>>n;
        int col[n]; 
        memset(col, 0, sizeof(col));
        
        int cnt = 0;
        int *count = &cnt;
        dfs(0, col, n, count);
        if(cnt == 0)
            cout<<-1;
        cout<<"\n";
    }
    return 0;
}

================================================================
68. Sudoku solver

#include<bits/stdc++.h>
using namespace std;

bool isSafe(int board[][9], int row , int col, int num){
    for(int i = 0 ; i < 9 ; i++){
        if(board[row][i] == num){
            return false;
        }
    }
    for(int i = 0 ; i < 9 ; i++){
        if(board[i][col] == num){
            return false;
        }
    }
    int rowStart = row - row%3;
    int colStart = col - col%3;
    for(int i = rowStart ; i < rowStart +3 ; i++){
        for(int j = colStart ; j < colStart +3 ; j++){
            if(board[i][j] == num){
                return false;
            }
        }
    }
    return true;
}

bool sudokuSolver(int board[][9]){
    
    int row=-1,col=-1;
    bool isBlank = false;
    for(int i = 0 ; i < 9 ; i++){
        for(int j = 0 ; j < 9 ; j++){
            if(board[i][j] == 0){
                row = i;
                col = j;
                isBlank = true;
                break;
            }
        }
        if(isBlank == true){
            break;
        }
    }
    
    if(isBlank == false){
        return true;
    }
    
    for(int i = 1 ; i <=9 ; i++){
        if(isSafe(board,row,col,i)){
            board[row][col] = i;
            if(sudokuSolver(board) == true){
                return true;
            }
            board[row][col] = 0;
        }
    }
    return false;
}

int main()
 {
	//code
	int t;
	cin>>t;
	while(t--){
	    int board [9][9];
	    for(int i = 0 ; i < 9 ; i++){
	        for(int j =0; j < 9 ; j++){
	            cin>>board[i][j];
	        }
	    }
	    
	    if(sudokuSolver(board)){
	    for(int i = 0 ; i < 9 ; i++){
	        for(int j =0; j < 9 ; j++){
	            cout<<board[i][j]<<" ";
	        }
	    }
	    
	cout<<endl;  
	}
	}
	return 0;
}

=================================================================
69. all permutation of a string

#include<bits/stdc++.h>
using namespace std;
vector<string> ans;
void allPermutations(string S, int l, int r){
    if(l == r){
        ans.push_back(S);
    } else {
        for(int i = l ; i <= r ; i++){
            swap(S[l],S[i]);
            //sort(S + l + 1, S + S.size());
            allPermutations(S,l+1,r);
            //sort(S + l + 1, S + S.size());
            swap(S[l],S[i]);
        }
    }
}

int main()
 {
	//code
	int t;
	cin>>t;
	while(t--){
	    string S;
	    cin>>S;
	    allPermutations(S, 0, S.size() - 1);
	    sort(ans.begin(), ans.end());
	    for(int i=0 ; i < ans.size() ; i++){
	        cout<<ans[i]<<" ";
	    }
	    ans.clear();
	    cout<<endl;
	}
	return 0;
}

====================================================
70. Adding one

vector<int> addOne(int a[], int n) {
        // code here
        int carry;
        vector<int> ans(n);
        ans[n-1] = a[n-1] + 1;
        carry = ans[n-1]/10;
        ans[n-1] = ans[n-1]%10;
        for(int i = n-2 ; i >= 0 ; i--){
            if(carry == 1){
                ans[i] = a[i] + carry;
                carry = ans[i]/10;
                ans[i] = ans[i]%10;
                //cout<<ans[i];
            } else {
                ans[i] = a[i];
            }
        }
        if(carry == 1){
            ans.insert(ans.begin(), 1);
        }
        
        return ans;
        
        }

====================================================
71. sums of substrings- recursion

#include<bits/stdc++.h>
using namespace std;

void subsetSums(vector<int> &arr, vector<int> &sums, int l, int r, int sum=0 ){
    if(l>r){
        sums.push_back(sum);
        return;
    }
    
    subsetSums(arr,sums,l+1,r,sum + arr[l]);
    subsetSums(arr,sums,l+1,r, sum);
    
    
    
}

int main()
 {
	//code
	int t;
	cin>>t;
	while(t--){
	    int n ;
	    cin>>n;
	    vector<int> arr(n);
	    for(int i = 0 ; i < n ; i++){
	        cin>>arr[i];
	    }
	    vector<int> sums;
	    subsetSums(arr,sums,0,n-1);
	    sort(sums.begin(), sums.end());
	    for(int i = 0 ; i < sums.size() ; i++){
	        cout<<sums[i]<<" ";
	    }
	    cout<<endl;
	}
	return 0;
}

===============================================================
72. print pattern - recursion - gfg

#include <bits/stdc++.h>
using namespace std;

void pattern(int n, int N, int flag){
    if(n == N && flag== 1){
        cout<<n;
        return;
    }
    
    cout<<n<<" ";
    if(flag == 0){
        if(n<=0){
            pattern(n+5,N,1);
        } else {
            pattern(n-5,N,0);
        }
    } else {
        pattern(n+5,N,1);
    }
}

int main() {
	//code
	int t;
	cin>>t;
	while(t--){
	 int n;
	 cin>>n;
	 pattern(n,n,0);
	 cout<<endl;
	}
	return 0;
}
==========================================================
73. combination sum - leetcode

void findComb(vector<int> &candidates, int target, vector<int> &ans, vector<vector<int>> &sol, int index){
        if(target == 0){
            sol.push_back(ans);
            return;
        }
        if(target < 0){
            return;
        }
        while(index < candidates.size() && target >=0){
            ans.push_back(candidates[index]);
            findComb(candidates,target - candidates[index], ans,sol,index);
            index++;
            ans.pop_back();
        }
        return;
    }
    
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        
        candidates.erase(unique(candidates.begin(),candidates.end()), candidates.end());
    
        vector<int> ans;
        vector<vector<int>> sol;
        findComb(candidates,target,ans,sol, 0);
        
        return sol;
    }
======================================================
74. combination sum 2 - lc

void findComb(vector<int> &candidates, int target, vector<int> &ans, set<vector<int>> &sol, int i, int j){
        if(target == 0){
            sol.insert(ans);
            return;
        }
        if(target < 0){
            return;
        }
        while(i < candidates.size() ){
            while(j < candidates.size() && target >= 0){
                ans.push_back(candidates[j]);
                findComb(candidates, target - candidates[j], ans,sol,i,j+1);
                j++;
                ans.pop_back();
            }
            i++;
        }
        return;
    }
    
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        //candidates.erase(unique(candidates.begin(), candidates.end()), candidates.end());
        vector<int> ans;
        set<vector<int>> sol;
        findComb(candidates,target, ans,sol,0,0);
        vector<vector<int>> uniqSol;
        for(auto itr = sol.begin(); itr != sol.end() ; itr++){
            uniqSol.push_back(*itr);
        }
        return uniqSol;
    }
==========================================================================
75. count good triplets - lc

  int countGoodTriplets(vector<int>& arr, int a, int b, int c) {
        int n = arr.size();
        int count=0;
        for(int i = 0 ; i < n ; i++ ){
            for(int j = i+1 ; j < n  ; j++ ){
                for(int k = j+1 ; k < n ; k++){
                    if(abs(arr[j] - arr[i]) <= a && abs(arr[k] - arr[j]) <= b && abs(arr[k] - arr[i]) <= c){
                        count++;
                    }
                }
            }
        }
        return count;
    }
===========================================================================
76. find winner of an array game- lc

int getWinner(vector<int>& arr, int k) {
       int currentMax;
        unordered_map<int,int> matchesWon;
        currentMax = arr[0];
        for(int i = 1 ; i < arr.size() ; i++){
            currentMax = max(currentMax, arr[i]);
            matchesWon[currentMax]++;
            if(matchesWon[currentMax] == k){
                return currentMax;
            }
        }
        return currentMax;
    }

==========================================================================
77. find nth root of m - gfg 
https://practice.geeksforgeeks.org/problems/find-nth-root-of-m/0

#include<bits/stdc++.h>
using namespace std;

void findRoot(int n, int m){
   int l = 1, h = m, mid;
   int f = 0;
   long long int k;
   while(l <= h){
       mid = l + (h-l)/2;
       k = 1;
       for(int i = 1; i <= n ; i++){
           k = k*mid;
           if(k>m){
               break;
           }
       }
           if(k == m){
               f = 1;
               break;
           } else if(k < m){
               l = mid+1;
           } else if(k > m){
               h = mid - 1;
           }
       }
   if(f==1){
       cout<<mid<<endl;
   } else {
       cout<<-1<<endl;
   }
}

int main()
 {
	//code
	int t;
	cin>>t;
	while(t--){
	    int n, m;
	    cin>>n>>m;
	    findRoot(n,m);
	}
	return 0;
}
============================================================================
78. Median in a row-wise sorted matrix - gfg
https://practice.geeksforgeeks.org/problems/median-in-a-row-wise-sorted-matrix1527/1
 int median(vector<vector<int>> &matrix, int r, int c){
        // code here       
        int min = INT_MAX, max = INT_MIN;
        for(int i = 0; i < r ; i++){
            if(matrix[i][0] < min){
                min = matrix[i][0];
            }
            if(matrix[i][c - 1] > max){
                max = matrix[i][c - 1];
            }
        }
        int desired = (r*c + 1)/2;
        while(min < max){
            int mid = min + (max - min)/2;
            int place = 0;
            for(int i = 0 ; i < r ; i++){
                for(int j = 0 ; j < c ; j++){
                    if(matrix[i][j] <= mid){
                        place++;
                    } else {
                        break;
                    }
                }
            }
            if(place < desired){
                min = mid+1;
            } else {
                max = mid;
            }
        }
       return min; 
    }

Expected Time Complexity: O(32 * R * log(C))
Expected Auxiliary Space: O(1)

Algorithm:

1.First we find the minimum and maximum elements in the matrix. Minimum element can be easily found by comparing the first element of each row, and similarly the maximum element can be found by comparing the last element of each row.
2.Then we use binary search on our range of numbers from minimum to maximum, we find the mid of the min and max, and get count of numbers less than our mid. And accordingly change the min or max.
3.For a number to be median, there should be (r*c)/2 numbers smaller than that number. So for every number, we get the count of numbers less than that by using upper_bound() ( 
for (int i = 0; i < r; ++i) 
            place += upper_bound(m[i], m[i]+c, mid) - m[i];
 ) in each row of matrix, if it is less than the required count, the median must be greater than the selected number, else the median must be less than or equal to the selected number.
=========================================================================================
79. Find the element that appears once in sorted array -gfg
https://practice.geeksforgeeks.org/problems/find-the-element-that-appears-once-in-sorted-array0624/1

int find(int arr[], int l, int r){
      if(l>r){
          return -1;
      }
      if(l == r){
          //cout<<l<<" ";
          return arr[l];
      } 
      int m = (r + l)/2;
      
      if(m%2 == 0){
           if(arr[m] == arr[m + 1]) {
            find(arr, m + 2, r); 
           } else {
            find(arr, l, m);
           }
      } else {
          if(arr[m] == arr[m-1]) {
              find(arr, m+1, r);
          } else {
           find(arr, l, m-1);   
          }
      }
  }
    int findOnce(int arr[], int n)
    {
        //code here.
        //int l = 0;
        //int r = n - 1;
        
       return find(arr,0,n-1);
    }

=======================================================================================
80. Search in rotated sorted array - lc
https://leetcode.com/problems/search-in-rotated-sorted-array/
int search(vector<int>& nums, int target) {
       int l = 0, r = nums.size() - 1;
        int mid;
        while(l<=r){
            mid = l + (r - l)/2 ;
            if(nums[mid] == target){
                return mid;
            }
            if(nums[l] <= nums[mid]){
                if(nums[l] <= target && target < nums[mid]){
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if(nums[r] >= target && target > nums[mid]){
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
=========================================================================

